<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Neon Drift — Dodge Game</title>
  <meta name="description" content="เกมหลบสิ่งกีดขวางสไตล์นีออน เล่นได้ทั้งมือถือและคอม — สร้างด้วย Canvas ไฟล์เดียว พร้อมลง GitHub Pages" />
  <style>
    :root{
      --bg:#0a0c10;
      --fg:#e2e8f0;
      --muted:#94a3b8;
      --accent:#22d3ee; /* cyan */
      --accent2:#a78bfa; /* violet */
      --danger:#fb7185; /* rose */
      --glass: rgba(255,255,255,.06);
      --glass-2: rgba(255,255,255,.12);
      --radius: 16px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    html,body{height:100%;}
    body{
      margin:0; background: radial-gradient(1200px 800px at 20% 10%, #0f172a 0%, #0b1220 30%, var(--bg) 70%) fixed;
      color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", "Noto Sans", Arial, "Helvetica Neue", Helvetica, "Kanit", sans-serif;
      overflow:hidden;
    }
    /* Canvas wraps */
    #wrap{position:fixed; inset:0;}
    canvas{width:100%; height:100%; display:block;}

    /* UI */
    .hud{position:fixed; inset:0; pointer-events:none;}
    .topbar{display:flex; justify-content:space-between; align-items:center; gap:.75rem; position:absolute; left:16px; right:16px; top:16px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,.15); padding:10px 14px; border-radius:var(--radius); box-shadow:var(--shadow); pointer-events:auto;}
    .brand{display:flex; align-items:center; gap:.6rem; font-weight:700; letter-spacing:.3px;}
    .brand .dot{width:10px; height:10px; border-radius:99px; background: radial-gradient(circle at 30% 30%, var(--accent), #0ea5e9 60%, transparent 70%); box-shadow:0 0 16px 6px rgba(34,211,238,.5), 0 0 40px rgba(167,139,250,.35) inset;}
    .score{font-variant-numeric:tabular-nums; display:flex; gap:12px; align-items:center;}
    .pill{padding:6px 10px; border-radius:999px; background:var(--glass); border:1px solid rgba(255,255,255,.15);}
    .btn{pointer-events:auto; cursor:pointer; user-select:none; border:none; color:var(--fg); background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.16); padding:8px 12px; border-radius:12px; box-shadow:var(--shadow); transition:transform .08s ease, background .2s ease;}
    .btn:hover{transform: translateY(-1px);} 
    .btn:active{transform: translateY(0);} 

    .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center;}
    .card{width:min(92vw,720px); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.16); padding:24px; border-radius:24px; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); box-shadow:var(--shadow); text-align:center;}
    .title{font-size:clamp(26px, 5vw, 40px); font-weight:800; letter-spacing:.5px; margin:8px 0 4px;}
    .subtitle{color:var(--muted); margin:0 0 22px;}
    .row{display:flex; flex-wrap:wrap; gap:12px; justify-content:center; align-items:center;}
    .kbd{font-variant: all-small-caps; letter-spacing:.6px; padding:6px 10px; border-radius:10px; background:var(--glass); border:1px solid rgba(255,255,255,.14)}
    .small{color:var(--muted); font-size:13px;}
    .badges{display:flex; justify-content:center; gap:8px; margin:10px 0 0; flex-wrap:wrap}

    .hidden{display:none !important}

    .footer{position:absolute; bottom:16px; left:50%; transform:translateX(-50%); color:var(--muted); font-size:12px}
    a{color:var(--accent)}
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game"></canvas></div>
  <div class="hud">
    <div class="topbar">
      <div class="brand"><div class="dot"></div> Neon Drift</div>
      <div class="score">
        <div class="pill">คะแนน: <span id="score">0</span></div>
        <div class="pill">สถิติ: <span id="best">0</span></div>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">พัก/ต่อ</button>
        <button id="btnRestart" class="btn">เริ่มใหม่</button>
      </div>
    </div>

    <div id="startOverlay" class="overlay">
      <div class="card">
        <div class="title">NEON DRIFT</div>
        <div class="subtitle">หลบลูกอุกกาบาตนีออนให้นานที่สุด ✨</div>
        <div style="margin:14px 0 18px" class="small">วิธีเล่น: ลากเมาส์/นิ้ว เพื่อบังคับวงกลมเรืองแสง ห้ามชนสิ่งกีดขวาง</div>
        <div class="row" style="margin-bottom:16px">
          <span class="kbd">เมาส์/นิ้ว</span>
          <span class="kbd">Space = พัก</span>
          <span class="kbd">R = เริ่มใหม่</span>
        </div>
        <div class="badges small">
          <span class="pill">60 FPS</span>
          <span class="pill">Canvas 2D</span>
          <span class="pill">Responsive</span>
          <span class="pill">LocalStorage</span>
        </div>
        <div style="margin-top:18px" class="row">
          <button id="btnStart" class="btn" style="font-weight:700; padding:10px 16px">เริ่มเกม</button>
        </div>
      </div>
    </div>

    <div id="gameoverOverlay" class="overlay hidden">
      <div class="card">
        <div class="title">Game Over</div>
        <p class="subtitle">คุณอยู่รอดได้ <b><span id="finalScore">0</span></b> แต้ม</p>
        <div class="row">
          <button id="btnTryAgain" class="btn">เล่นอีกครั้ง</button>
          <button id="btnShare" class="btn">แชร์คะแนน</button>
        </div>
      </div>
    </div>

    <div class="footer">สร้างด้วย ♥️ โดยคุณบน GitHub Pages</div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    let W = 0, H = 0;
    function resize(){
      W = Math.floor(window.innerWidth * dpr);
      H = Math.floor(window.innerHeight * dpr);
      canvas.width = W; canvas.height = H;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', resize, { passive:true });
    resize();

    // Utility
    const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
    const rand = (a,b)=> a + Math.random()*(b-a);
    const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1, y2-y1);

    // Game State
    const state = {
      running: false,
      paused: false,
      score: 0,
      best: Number(localStorage.getItem('neon.best')||0),
      time: 0,
      gameOver: false,
      spawnTimer: 0,
      spawnInterval: 700,
      difficulty: 1,
    };

    // Parallax starfield
    const stars = [];
    function resetStars(){
      stars.length = 0;
      const layers = 3;
      for(let l=0; l<layers; l++){
        const count = Math.floor((W*H/9000) * (l+1)/layers);
        for(let i=0;i<count;i++){
          stars.push({
            x: Math.random()*W,
            y: Math.random()*H,
            z: l+1,
            s: rand(0.5, 1.6)*(l+1)/layers
          })
        }
      }
    }
    resetStars();
    window.addEventListener('resize', resetStars);

    // Player
    const player = {
      x: W*0.5, y: H*0.7, r: 14*dpr, vx:0, vy:0,
      tx: null, ty: null,
      trail: [],
    };

    // Input
    canvas.addEventListener('pointerdown', e=>{
      const rect = canvas.getBoundingClientRect();
      player.tx = (e.clientX - rect.left) * dpr;
      player.ty = (e.clientY - rect.top) * dpr;
    });
    canvas.addEventListener('pointermove', e=>{
      if(player.tx==null) return;
      const rect = canvas.getBoundingClientRect();
      player.tx = (e.clientX - rect.left) * dpr;
      player.ty = (e.clientY - rect.top) * dpr;
    });
    window.addEventListener('pointerup', ()=>{ player.tx=null; player.ty=null; });

    window.addEventListener('keydown', e=>{
      if(e.code==='Space'){ togglePause(); }
      if(e.key==='r' || e.key==='R'){ if(!state.running||state.gameOver) start(); else restart(); }
    });

    // Objects
    const obstacles = [];
    const particles = [];

    function spawnObstacle(){
      const speed = rand(1.8, 3.2) * dpr * (1 + state.difficulty*0.1);
      const size = rand(10, 22) * dpr * (1 + state.difficulty*0.08);
      const x = rand(size, W-size);
      const hue = rand(180, 300);
      obstacles.push({ x, y: -size-10, r: size, vy: speed, hue, rot: rand(0, Math.PI*2), vr: rand(-0.03, 0.03) });
    }

    function explode(x,y, hue){
      for(let i=0;i<18;i++){
        particles.push({
          x, y, life: rand(0.6,1.2), age:0,
          vx: Math.cos(i/18*Math.PI*2)*rand(40,140)*dpr,
          vy: Math.sin(i/18*Math.PI*2)*rand(40,140)*dpr,
          hue: hue + rand(-10,10),
        })
      }
    }

    function start(){
      state.running = true; state.gameOver = false; state.paused=false; state.time=0; state.score=0; state.spawnTimer=0; state.difficulty=1;
      obstacles.length=0; particles.length=0; player.trail.length=0;
      player.x = W*0.5; player.y = H*0.7; player.vx=0; player.vy=0; player.r = 14*dpr;
      document.getElementById('startOverlay').classList.add('hidden');
      document.getElementById('gameoverOverlay').classList.add('hidden');
    }

    function restart(){ start(); }
    function gameOver(){
      state.gameOver=true; state.running=false;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem('neon.best', String(state.best));
      document.getElementById('finalScore').textContent = Math.floor(state.score);
      document.getElementById('gameoverOverlay').classList.remove('hidden');
    }

    function togglePause(){
      if(!state.running) return;
      state.paused = !state.paused;
    }

    // UI events
    document.getElementById('btnStart').onclick = start;
    document.getElementById('btnTryAgain').onclick = start;
    document.getElementById('btnRestart').onclick = restart;
    document.getElementById('btnPause').onclick = togglePause;
    document.getElementById('btnShare').onclick = ()=>{
      const msg = `ฉันทำคะแนนได้ ${Math.floor(state.score)} ใน NEON DRIFT! ลองเล่นสิ`;
      if(navigator.share){ navigator.share({ title: 'Neon Drift', text: msg, url: location.href }).catch(()=>{}); }
      else { navigator.clipboard.writeText(msg + ' ' + location.href).then(()=> alert('คัดลอกข้อความแล้ว!')); }
    }

    // Render helpers
    function drawGlowCircle(x,y,r, color){
      const g = ctx.createRadialGradient(x,y, r*0.2, x,y, r*1.6);
      g.addColorStop(0, `hsla(${color}, 95%, 70%, 0.95)`);
      g.addColorStop(1, `hsla(${color}, 95%, 50%, 0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x,y,r*1.6,0,Math.PI*2); ctx.fill();
      // core
      const g2 = ctx.createRadialGradient(x,y, r*0.0, x,y, r);
      g2.addColorStop(0, `hsla(${color}, 95%, 80%, 1)`);
      g2.addColorStop(1, `hsla(${color}, 95%, 50%, .0)`);
      ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }

    function drawObstacle(o){
      // neon diamond
      const r = o.r; const x=o.x, y=o.y;
      ctx.save();
      ctx.translate(x,y); ctx.rotate(o.rot);
      const path = new Path2D();
      path.moveTo(0,-r); path.lineTo(r,0); path.lineTo(0,r); path.lineTo(-r,0); path.closePath();
      const g = ctx.createLinearGradient(-r,-r, r,r);
      g.addColorStop(0, `hsla(${o.hue},90%,65%,.9)`);
      g.addColorStop(1, `hsla(${o.hue+40},90%,55%,.7)`);
      ctx.fillStyle = g; ctx.shadowColor = `hsla(${o.hue},90%,60%,.9)`; ctx.shadowBlur = r*0.9;
      ctx.fill(path);
      // inner lines
      ctx.shadowBlur = 0; ctx.lineWidth = Math.max(1, r*0.12); ctx.strokeStyle = `hsla(${o.hue+20}, 100%, 75%, .7)`;
      ctx.stroke(path);
      ctx.restore();
    }

    function drawTrail(){
      if(player.trail.length<2) return;
      ctx.save();
      ctx.lineWidth = Math.max(1.5*dpr, player.r*0.35);
      ctx.lineCap = 'round';
      for(let i=1;i<player.trail.length;i++){
        const a = player.trail[i-1], b = player.trail[i];
        const t = i/player.trail.length;
        ctx.strokeStyle = `hsla(${200+80*t}, 90%, ${60-20*t}%, ${0.35-0.3*t})`;
        ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
      ctx.restore();
    }

    // Loop
    let last = performance.now();
    function frame(now){
      const dt = Math.min(50, now - last); last = now;

      // Clear
      ctx.fillStyle = '#070a12';
      ctx.fillRect(0,0,W,H);

      // Starfield parallax
      for(const s of stars){
        const spd = (s.z*0.2 + state.difficulty*0.03) * dpr;
        s.y += spd * (dt/16.67);
        if(s.y>H){ s.y -= H; s.x = Math.random()*W; }
        ctx.globalAlpha = 0.2 + s.z*0.15;
        ctx.fillStyle = '#9bdcff';
        ctx.fillRect(s.x, s.y, s.s, s.s);
      }
      ctx.globalAlpha = 1;

      if(state.running && !state.paused && !state.gameOver){
        state.time += dt;
        state.score += dt*0.02 * (1 + state.difficulty*0.2);
        state.spawnTimer += dt;
        if(state.spawnTimer >= state.spawnInterval){
          state.spawnTimer = 0;
          spawnObstacle();
          // ramp difficulty slowly
          state.difficulty += 0.05;
          state.spawnInterval = clamp(700 - state.difficulty*20, 260, 700);
        }
      }

      // Player move towards target
      if(player.tx!=null && !state.paused && !state.gameOver){
        const ax = (player.tx - player.x) * 0.06;
        const ay = (player.ty - player.y) * 0.06;
        player.vx = (player.vx + ax) * 0.90;
        player.vy = (player.vy + ay) * 0.90;
      } else {
        player.vx *= 0.92; player.vy *= 0.92;
      }
      player.x = clamp(player.x + player.vx*(dt/16.67), player.r, W-player.r);
      player.y = clamp(player.y + player.vy*(dt/16.67), player.r, H-player.r);

      // Trail update
      player.trail.push({x:player.x, y:player.y});
      if(player.trail.length>24) player.trail.shift();

      // Obstacles update
      for(let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        if(state.running && !state.paused && !state.gameOver){
          o.y += o.vy*(dt/16.67); o.rot += o.vr*(dt/16.67);
        }
        drawObstacle(o);
        if(o.y - o.r > H+60){ obstacles.splice(i,1); }
        if(!state.gameOver){
          const d = dist(player.x, player.y, o.x, o.y);
          if(d < player.r + o.r*0.8){
            explode(player.x, player.y, 200);
            gameOver();
          }
        }
      }

      // Particles
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.age += dt/1000;
        p.x += p.vx*(dt/1000); p.y += p.vy*(dt/1000);
        p.vx *= 0.98; p.vy *= 0.98; // drag
        const t = 1 - p.age/p.life;
        if(t<=0){ particles.splice(i,1); continue; }
        ctx.globalAlpha = Math.max(0, t*0.9);
        drawGlowCircle(p.x, p.y, 6*dpr, p.hue);
        ctx.globalAlpha = 1;
      }

      // Player
      drawTrail();
      drawGlowCircle(player.x, player.y, player.r, 200);

      // HUD
      document.getElementById('score').textContent = Math.floor(state.score);
      document.getElementById('best').textContent = state.best;

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);

    // Expose for debug
    window.__NEON__ = { state, player, obstacles };
  })();
  </script>
</body>
</html>
